# -*- coding: utf-8 -*-
"""HyperbolicPoincareRiemannianOpt.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/132nPifYdtpjx8cs9N-e0fpdEZJqGGC9Q

# riferimenti
- https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/hyperbolic.html
- https://geoopt.readthedocs.io/en/poincare/extended/poincare.html
- https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7108814/
- http://proceedings.mlr.press/v119/bose20a/bose20a.pdf
"""

import numpy as np
from random import random
import math
import matplotlib.pyplot as plt
from random import random
from numpy import linalg as LA

"""# Poincare Ball

"""

# poincare exponential
def lambda_x(x, c=1):
  """
  Compute the conformal factor ùúÜùëêùë• for a point on the ball
  that connects Euclidean inner product with Riemannian one
  """
  return 2/(1 - c*(np.dot(x, x)))

def riemannian_norm(v, x, c=1):
  return lambda_x(x, c)**c*math.sqrt(np.dot(v, v))

def mobius_add(x, y, c=1):
  """
  special operation over hyperbolic space
  """
  x_dot_y = np.dot(x, y)
  x_norm_q = np.dot(x, x)
  y_norm_q = np.dot(y, y)

  num = (1 + 2*c*x_dot_y + c*y_norm_q)*x + (1 - c*x_norm_q)*y
  den = 1 + 2*c*x_dot_y + c**2*x_norm_q*y_norm_q

  return num/den

def mobius_scalar_mul(r, x, c=1):
  x_norm_2 = math.sqrt(np.dot(x,x))
  sqrt_c = math.sqrt(c)
  return (1/sqrt_c)*np.tanh(r*np.arctanh(sqrt_c*x_norm_2))*x/x_norm_2

def geodesic_unit(t, x, v, c=1):
  """
  Unit speed geodesic starting from x with direction v/‚Äñv‚Äñx
  """
  
  tmp = np.tanh(t*math.sqrt(c)/2)*(v/(math.sqrt(c)*math.sqrt(np.dot(v,v))))
  
  return mobius_add(x, tmp, c)

def poincare_exp(x, v, c=1):
  tmp = np.tanh(math.sqrt(c)/2*riemannian_norm(v, x, c))*(v/(math.sqrt(c)*math.sqrt(np.dot(v,v))))
  
  return mobius_add(x, tmp, c)

def poincare_dist(x, y):
  return np.arccosh(1 + 2*(np.dot(x-y, x-y)/((1-np.dot(x,x))*(1-np.dot(y,y)))))

def grad_poincare_dist(x, y):
  a = 1 - np.dot(x, x)
  b = 1 - np.dot(y, y)
  c = 1 + 2/(a*b)*(np.dot(x-y, x-y))

  return 4/(b*math.sqrt(c**2-1))*(((np.dot(y,y) - 2*np.dot(x, y) + 1)/a**2)*x - y/a)

def frechet_mean_poincare_grad(psi, x_set):
  res = 0
  for x_i in x_set:
    res += poincare_dist(psi, x_i)*grad_poincare_dist(psi, x_i)
  return res*2*(len(x_set))

def frechet_mean_poincare_grad_euclidean(psi, x_set):
  return frechet_mean_poincare_grad(psi, x_set)*(lambda_x(psi)**2)

def poincare_transport(psi_1, psi_2, v):
  return v # identity transport, cercare un trasporto valido

def poincare_log(x, y, c=1):
  """
  Logarithmic map for two points ùë• and ùë¶ on the manifold.
  """
  a = mobius_add(-x, y, c)
  b = math.sqrt(np.dot(a, a))
  c = 2/(math.sqrt(c)*lambda_x(x, c))*np.arctanh(math.sqrt(c)*b)
  return c*a/b

"""# Hyperboloid"""

def minkowski_dot(x, y):
  return np.dot(x[:-1], y[:-1]) - x[-1]*y[-1]


def hyperboloid_dist(x, y):
  return np.arccosh(-minkowski_dot(x, y))


def minkowski_gradient(theta, x_set):
  res = 0
  for x_i in x_set:
    res += -(hyperboloid_dist(theta, x_i) * (minkowski_dot(theta, x_i)**2 - 1)**(-1/2) ) * x_i
  res = res*2/(len(x_set))
  return res


def hyperboloid_gradient(theta, x_set):
  mink_grad = minkowski_gradient(theta, x_set)
  res = mink_grad + minkowski_dot(theta, mink_grad) * theta
  if minkowski_dot(res, res) < 10e-16:
    res = np.zeros(theta.shape)
    res.fill(10e-16)
  return res

# la norma non deve essere quella euclidea ma quella riemanniana
# da cio dobbiamo evitare errori di calcolo nel gradiente poiche potrebbe non essere 
def hyperboloid_exp(theta, v):
  # return np.cosh(math.sqrt(np.dot(v, v)))*theta + np.sinh(math.sqrt(np.dot(v, v)))*(v/math.sqrt(np.dot(v, v)))
  return np.cosh(math.sqrt(minkowski_dot(v, v)))*theta + np.sinh(math.sqrt(minkowski_dot(v, v)))*(v/math.sqrt(minkowski_dot(v, v)))


def hyperboloid_log(theta_1, theta_2):
  #tmp = theta_2-minkowski_dot(theta_1, theta_2)*theta_1
  #return hyperboloid_dist(theta_1, theta_2)*(tmp)/(np.dot(tmp, tmp)**(1/2))
  alpha = -minkowski_dot(theta_1, theta_2)
  return (np.arccosh(alpha)/((alpha**2 - 1)**(1/2)))*(theta_2 - alpha*theta_1)

def hyperboloid_transport(theta_1, theta_2, v):
  return v # identity transport
  # return v - (minkowski_dot(hyperboloid_log(theta_1, theta_2), v)/hyperboloid_dist(theta_1, theta_2)**2)*(hyperboloid_log(theta_1, theta_2) + hyperboloid_log(theta_2, theta_1))

def frechet_mean(theta, x_set, distance):
  sum_ = 0
  s = len(x_set)
  for x_i in x_set:
    sum_ += distance(theta, x_i)**2
  return sum_/s

def poincare_points_factory(norm=1):
  # non √® uniforme nel disco di poincar√©, ma √® piu vicino al centro
  z = random()
  t = random()*2*math.pi
  return np.array([z*np.cos(t), z*np.sin(t)])


def rho(x):
  return x[:-1]/(x[-1]+1)


def inv_rho(y):
  r = np.dot(y,y)
  return np.array(np.append(y[:],[(1+r)/2]))*2/(1-r) 


def plot_alg(seq, x_set, ax):
  x = np.linspace(-1.0, 1.0, 100)
  y = np.linspace(-1.0, 1.0, 100)
  X, Y = np.meshgrid(x,y)
  F = X**2 + Y**2 - 1
  ax.contour(X,Y,F,[0])

  seq = np.array(seq)
  x_set = np.array(x_set)

  ax.scatter(seq[:, 0], seq[:, 1], c="red", marker="x")
  ax.scatter(seq[-1, 0], seq[-1, 1], c="green", marker="^")
  ax.scatter(x_set[:, 0], x_set[:, 1], c="blue", marker="o")


def convergence_seq(psi_seq):
  limit = psi_seq[-1]
  return [poincare_dist(psi, limit) for psi in psi_seq]


# TODO: sostituire norma euclidea con variabile a seconda del metodo del calcolo
# del gradiente
def plot_seq(psi_seq, f_seq, g_seq):
  fig = plt.figure(figsize=[12.8, 12.8])
  fig.clf()
  gs = fig.add_gridspec(2, 2)
  ax1 = fig.add_subplot(gs[0, 0])
  ax1.title.set_text("poincar√© ball over complexes (R^2)")
  ax2 = fig.add_subplot(gs[1, 0])
  ax2.title.set_text("error sequence")
  ax3 = fig.add_subplot(gs[0, 1])
  ax3.title.set_text("f sequence")
  ax4 = fig.add_subplot(gs[1, 1])
  ax4.title.set_text("g-norm sequence")

  plot_alg(psi_seq, x_set, ax1)
  conv_seq = convergence_seq(psi_seq)
  ax2.semilogy(conv_seq)
  ax3.semilogy(f_seq)
  g_norm = [LA.norm(g) for g in g_seq]
  ax4.semilogy((g_norm))

x_set = [poincare_points_factory() for _ in range(4)]
psi_0 = np.array([0,0], dtype=np.float64) # poincare_points_factory() # calcolare come media dei punti x_set
for a_i in x_set:
  psi_0 += a_i
psi_0 /= len(x_set)

"""# Metodo iterativo

parte da un punto a_i e si va nella direzione del secondo seguendo la geodedica e ci si ferma ad 1/2 poi si va verso il terzo punto e si prosegue per 1/3 poi si va verso il quarto putno e si prosegue per 1/4 e cosi via. x_k+1 = exp(log(x_k, a_(k%p)), 1/k); p = # punti.  
converge al baricentro
"""

def iterative_method_poincare(x_set, max_steps=10):
  m = len(x_set)
  x_k = x_set[0]
  for i in range(1, max_steps):
    j = (i)%m
    a_j = x_set[j]
    x_k = poincare_exp(x_k, poincare_log(x_k, a_j)/(i+1))
  return x_k

def iterative_method_hyperboloid(x_set, max_steps=10):
  m = len(x_set)
  x_k = x_set[0]
  for i in range(1, max_steps):
    j = (i)%m
    a_j = x_set[j]
    x_k = hyperboloid_exp(x_k, hyperboloid_log(x_k, a_j)/(i+1))
  return x_k

limit = iterative_method_poincare(x_set, 100000)
print(limit)

limit = rho(iterative_method_hyperboloid([inv_rho(x) for x in x_set], 100000))
print(limit)

"""# Optimisations Algorithms

## Algoritmo Per il baricentro di riferimento
"""

from math import exp

# IANNAZZO IMPLEMENTATION
def poincare_points_factory_complex(norm=1):
  # non √® uniforme nel disco di poincar√©, ma √® piu vicino al centro
  z = random()
  t = random()*2*math.pi
  return np.complex(z*np.cos(t),z*np.sin(t))


def complex_sign(z: complex) -> complex:
  if z==0:
    return 1
  return z/np.absolute(z)


def poincare_tangent_complex(a: complex, b: complex) -> complex:
  s = (b-a)/(1-a.conjugate()*b)
  v = complex_sign(s) *(1-np.absolute(a)**2)
  v = v*np.arctanh(np.absolute(s))
  return v


def poincare_geodesic_complex(x: complex, v: complex, t: float) -> complex:
  tmp = 2*np.absolute(v)/(1-np.absolute(x)**2)
  num = (x+(complex_sign(v)))+(x-(complex_sign(v)))*exp(-tmp*t)
  den = (1+x.conjugate()*(complex_sign(v)))+(1-x.conjugate()*(complex_sign(v)))*exp(-tmp*t)
  return num/den


def r2_to_complex_array(points):
  return [np.complex(a[0], a[1]) for a in points]

def complex_to_r2_array(points):
  return [np.array([z.real, z.imag]) for z in points]

# implemento algoritmi del professor iannazzo come riferimento per il calcolo
# del baricentro
def poincare_barycenter_iannazzo(data, par, maxit=100):
  x0 = 0
  psi_seq = [x0]
  m = len(data)
  for k in range(m):
    x0=x0+data[k]/m

  for h in range(maxit):
    incr=0
    for k in range(m):
      ai=data[k]
      incr=incr+poincare_tangent_complex(x0,ai)
    x1=poincare_geodesic_complex(x0, incr, par)
    if np.absolute(x1-x0)<10e-15:
      break
    psi_seq.append(x0)
    x0=x1
  return psi_seq


def plot_psi_seq(psi_seq):
  fig = plt.figure(figsize=[6.4, 12.8])
  fig.clf()
  gs = fig.add_gridspec(2, 1)
  ax1 = fig.add_subplot(gs[0, 0])
  ax1.title.set_text("poincar√© ball over complexes (R^2)")
  ax2 = fig.add_subplot(gs[1, 0])
  ax2.title.set_text("error sequence")

  plot_alg(psi_seq, x_set, ax1)
  conv_seq = convergence_seq(psi_seq)
  ax2.semilogy(conv_seq)

x_set_complex = r2_to_complex_array(x_set)
seq = poincare_barycenter_iannazzo(x_set_complex, 0.1, 1000)
seq = complex_to_r2_array(seq)
print("Limit sequence poincare: ", seq[-1])
plot_psi_seq(seq)

"""## Fixed Length step size"""

def optimisation_fl_poincare(psi_0, learning_rate, x_set, max_steps=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  for i in range(max_steps):
    psi = psi_seq[-1]
    g = frechet_mean_poincare_grad(psi, x_set)
    new_psi=poincare_exp(psi, -learning_rate*g)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g)
  return psi_seq, f_seq, g_seq


def optimisation_fl_poincare_euclidean(psi_0, learning_rate, x_set, max_steps=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  for i in range(max_steps):
    psi = psi_seq[-1]
    g = frechet_mean_poincare_grad_euclidean(psi, x_set)
    new_psi=poincare_exp(psi, -learning_rate*g)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g)
  return psi_seq, f_seq, g_seq


def optimisation_fl_hyperboloid(psi_0, learning_rate, x_set, max_steps=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []
  x_set_h = [inv_rho(x_i) for x_i in x_set]

  for i in range(max_steps):
    psi = psi_seq[-1]
    theta=inv_rho(psi)
    g_h = hyperboloid_gradient(theta, x_set_h)
    new_theta = hyperboloid_exp(theta, -learning_rate*g_h)
    new_psi = rho(new_theta)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g_h)
  return psi_seq, f_seq, g_seq

psi_seq, f_seq, g_seq = optimisation_fl_poincare(psi_0, 0.001, x_set, 100)
print("Limit sequence poincare: ", psi_seq[-1])
print(f_seq)
plot_seq(psi_seq, f_seq, g_seq)

psi_seq, f_seq, g_seq = optimisation_fl_poincare_euclidean(psi_0, 0.0001, x_set, 100)
print("Limit sequence poincare euclideo: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq)

psi_seq, f_seq, g_seq = optimisation_fl_hyperboloid(psi_0, 0.1, x_set, 100)
print("Limit sequence iperboloide: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq)

"""### Armijo"""

def armijo_step_hiper_riemannian(theta, x_set_h, g_k, sigma, gamma, lambda_):
  h = 0
  while frechet_mean(hyperboloid_exp(theta, -(sigma**h)*lambda_*g_k), x_set_h, hyperboloid_dist) > frechet_mean(theta, x_set_h, hyperboloid_dist) - gamma*(sigma**h)*lambda_*minkowski_dot(g_k, g_k):
    h += 1
  return h

def armijo_opt_hiper_riemannian(psi_0, x_set, sigma, gamma, lambda_, max_iter=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []
  x_set_h = [inv_rho(x) for x in x_set]

  for k in range(max_iter):
    theta = inv_rho(psi_seq[-1])
    g_k = hyperboloid_gradient(theta, x_set_h)
    h_k = armijo_step_hiper_riemannian(theta, x_set_h, g_k, sigma, gamma, lambda_)
    new_theta = hyperboloid_exp(theta, -(sigma**h_k)*lambda_*g_k)
    new_psi = rho(new_theta)
    
    psi_seq.append(rho(new_theta))
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g_k)
  return psi_seq, f_seq, g_seq

def armijo_step_poincare_riemannian(psi, x_set, g_k, sigma, gamma, lambda_):
  h = 0
  while frechet_mean(poincare_exp(psi, -(sigma**h)*lambda_*g_k), x_set, poincare_dist) > frechet_mean(psi, x_set, poincare_dist) + gamma*(sigma**h)*lambda_*(lambda_x(psi)**2*np.dot(g_k, -g_k)):
    h += 1
  return h

def armijo_opt_poincare_riemannian(psi_0, x_set, sigma, gamma, lambda_, max_iter=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  for k in range(max_iter):
    psi = psi_seq[-1]
    g_k = frechet_mean_poincare_grad(psi, x_set)
    h_k = armijo_step_poincare_riemannian(psi, x_set, g_k, sigma, gamma, lambda_)
    new_psi = poincare_exp(psi, -(sigma**h_k)*lambda_*g_k)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g_k)
  return psi_seq, f_seq, g_seq

def armijo_step_poincare_euclidean(psi, x_set, g_k, d_k, sigma, gamma, lambda_):
  h = 0
  while frechet_mean(poincare_exp(psi, (sigma**h)*lambda_*d_k), x_set, poincare_dist) > frechet_mean(psi, x_set, poincare_dist) + gamma*(sigma**h)*lambda_*np.dot(g_k, d_k):
    h += 1
  return h

def armijo_opt_poincare_euclidean(psi_0, x_set, sigma, gamma, lambda_, max_iter=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  for k in range(max_iter):
    psi = psi_seq[-1]
    g_k = frechet_mean_poincare_grad_euclidean(psi, x_set)
    d_k = -g_k
    h_k = armijo_step_poincare_euclidean(psi, x_set, g_k, d_k, sigma, gamma, lambda_)
    new_psi = poincare_exp(psi, (sigma**h_k)*lambda_*d_k)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g_k)
  return psi_seq, f_seq, g_seq

psi_seq, f_seq, g_seq = armijo_opt_poincare_euclidean(psi_0, x_set, 0.3, 0.05, 0.6, 100)
print("Limit sequence poincare euclidean: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq)

psi_seq, f_seq, g_seq = armijo_opt_poincare_riemannian(psi_0, x_set, 0.01, 0.001, 1, 100)
print("Limit sequence poincare: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq)

psi_seq, f_seq, g_seq = armijo_opt_hiper_riemannian(psi_0, x_set, 0.3, 0.1, 0.7, 100)
print("Limit sequence iperboloide: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq)

"""### Barzilai-Borwein"""

def RBB_hyperboloid(psi_0, x_set, a_min, a_max, max_steps=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  x_set_h = [inv_rho(x_i) for x_i in x_set]
  theta_0 = inv_rho(psi_0)

  f_k_seq = []

  a_BB = a_min
  for k in range(max_steps):
    theta = inv_rho(psi_seq[-1])
    g_k = hyperboloid_gradient(theta, x_set_h)
    f_k_seq.append(frechet_mean(theta, x_set_h, hyperboloid_dist))
    a_k = a_BB
    new_theta = hyperboloid_exp(theta, -a_k*g_k)
    new_psi = rho(new_theta)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g_k)

    new_f = frechet_mean(new_theta, x_set_h, hyperboloid_dist)
    new_g = hyperboloid_gradient(new_theta, x_set_h)
    s_k = -a_k*hyperboloid_transport(theta, new_theta, g_k)
    y_k = new_g + s_k/a_k
    new_tau = minkowski_dot(s_k, s_k)/minkowski_dot(s_k, y_k)

    if minkowski_dot(s_k, y_k) > 0:
      a_BB = min(a_max, max(a_min, new_tau))
    else:
      a_BB = a_max
  return psi_seq, f_seq, g_seq

def BB_poincare(psi_0, x_set, a_min, a_max, max_steps=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []


  a_BB = a_min
  for k in range(max_steps):
    psi = psi_seq[-1]
    g_k = frechet_mean_poincare_grad_euclidean(psi, x_set)
    f_k = frechet_mean(psi, x_set, poincare_dist)
    a_k = a_BB
    new_psi = poincare_exp(psi, -a_k*g_k)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g_k)

    new_f = frechet_mean(new_psi, x_set, poincare_dist)
    new_g = frechet_mean_poincare_grad(new_psi, x_set)
    s_k = -a_k*poincare_transport(psi, new_psi, g_k)
    y_k = new_g + s_k/a_k
    new_tau = np.dot(s_k, s_k)/np.dot(s_k, y_k)

    if np.dot(s_k, y_k) > 0:
      a_BB = min(a_max, max(a_min, new_tau))
    else:
      a_BB = a_max
  return psi_seq, f_seq, g_seq

def RBB_poincare(psi_0, x_set, a_min, a_max, max_steps=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  f_k_seq = []

  a_BB = a_min
  for k in range(max_steps):
    psi = psi_seq[-1]
    g_k = frechet_mean_poincare_grad(psi, x_set)
    f_k_seq.append(frechet_mean(psi, x_set, poincare_dist))
    a_k = a_BB
    new_psi = poincare_exp(psi, -a_k*g_k)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g_k)

    new_f = frechet_mean(new_psi, x_set, poincare_dist)
    new_g = frechet_mean_poincare_grad(new_psi, x_set)
    s_k = -a_k*poincare_transport(psi, new_psi, g_k)
    y_k = new_g + s_k/a_k
    new_tau = lambda_x(new_psi)**2*np.dot(s_k, s_k)/(lambda_x(new_psi)**2*np.dot(s_k, y_k))

    if lambda_x(new_psi)**2*np.dot(s_k, y_k) > 0:
      a_BB = min(a_max, max(a_min, new_tau))
    else:
      a_BB = a_max
  return psi_seq, f_seq, g_seq

psi_seq, f_seq, g_seq = BB_poincare(psi_0, x_set, 0.0001, 0.001, 100)
print("Limit sequence poincare euclidean: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq)

psi_seq, f_seq, g_seq = RBB_poincare(psi_0, x_set, 0.0001, 0.001, 100)
print("Limit sequence poincare: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq)

# supporta un learnign rate piu alto convergendo in modo piu veloce
psi_seq, f_seq, g_seq = RBB_hyperboloid(psi_0, x_set, 0.01, 0.3, 100)
print("Limit sequence iperboloide: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq)