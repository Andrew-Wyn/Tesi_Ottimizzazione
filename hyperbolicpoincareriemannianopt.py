# -*- coding: utf-8 -*-
"""HyperbolicPoincareRiemannianOpt.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/132nPifYdtpjx8cs9N-e0fpdEZJqGGC9Q

Todo
* creare dataset significativi
* scelta del valore iniziale: effettuare piu volte algoritmo a spirale e poi calcolarne la media

# riferimenti
- https://juliamanifolds.github.io/Manifolds.jl/stable/manifolds/hyperbolic.html
- https://geoopt.readthedocs.io/en/poincare/extended/poincare.html
- https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7108814/
- http://proceedings.mlr.press/v119/bose20a/bose20a.pdf
"""

import numpy as np
from random import random
import math
import matplotlib.pyplot as plt
from random import random
from numpy import linalg as LA
from mpmath import mp, mpf, acosh
mp.dps = 32

"""# Poincare Ball

"""

# poincare exponential
def lambda_x(x, c=1):
  """
  Compute the conformal factor ùúÜùëêùë• for a point on the ball
  that connects Euclidean inner product with Riemannian one
  """
  return 2/(1 - c*(np.dot(x, x)))

def riemannian_norm(v, x, c=1):
  return lambda_x(x, c)**c*math.sqrt(np.dot(v, v))

def mobius_add(x, y, c=1):
  """
  special operation over hyperbolic space
  """
  x_dot_y = np.dot(x, y)
  x_norm_q = np.dot(x, x)
  y_norm_q = np.dot(y, y)

  num = (1 + 2*c*x_dot_y + c*y_norm_q)*x + (1 - c*x_norm_q)*y
  den = 1 + 2*c*x_dot_y + c**2*x_norm_q*y_norm_q

  return num/den

def mobius_scalar_mul(r, x, c=1):
  x_norm_2 = math.sqrt(np.dot(x,x))
  sqrt_c = math.sqrt(c)
  return (1/sqrt_c)*np.tanh(r*np.arctanh(sqrt_c*x_norm_2))*x/x_norm_2

def geodesic_unit(t, x, v, c=1):
  """
  Unit speed geodesic starting from x with direction v/‚Äñv‚Äñx
  """

  tmp = np.tanh(t*math.sqrt(c)/2)*(v/(math.sqrt(c)*math.sqrt(np.dot(v,v))))
  
  return mobius_add(x, tmp, c)

def poincare_exp(x, v, c=1):
  tmp = np.tanh(math.sqrt(c)/2*riemannian_norm(v, x, c))*(v/(math.sqrt(c)*math.sqrt(np.dot(v,v))))
  
  return mobius_add(x, tmp, c)

def poincare_dist(x, y):
  return np.arccosh(1 + 2*(np.dot(x-y, x-y)/((1-np.dot(x,x))*(1-np.dot(y,y)))))

def grad_poincare_dist(x, y):
  a = 1 - np.dot(x, x)
  b = 1 - np.dot(y, y)
  c = 1 + 2/(a*b)*(np.dot(x-y, x-y))
  
  return 4/(b*math.sqrt(c**2-1))*(((np.dot(y,y) - 2*np.dot(x, y) + 1)/a**2)*x - y/a)

def frechet_mean_poincare_grad(psi, x_set):
  res = 0
  for x_i in x_set:
    res += poincare_dist(psi, x_i)*grad_poincare_dist(psi, x_i)
  return res*2*(len(x_set))

def frechet_mean_poincare_grad_euclidean(psi, x_set):
  return frechet_mean_poincare_grad(psi, x_set)*(lambda_x(psi)**2)

def poincare_transport(psi_1, psi_2, v):
  return v # identity transport, cercare un trasporto valido

def poincare_log(x, y, c=1):
  """
  Logarithmic map for two points ùë• and ùë¶ on the manifold.
  """
  a = mobius_add(-x, y, c)
  b = math.sqrt(np.dot(a, a))
  c = 2/(math.sqrt(c)*lambda_x(x, c))*np.arctanh(math.sqrt(c)*b)
  return c*a/b

"""# Hyperboloid"""

def minkowski_dot(x, y):
  return np.dot(x[:-1], y[:-1]) - x[-1]*y[-1]


def hyperboloid_dist(x, y):
  return np.arccosh(-minkowski_dot(x, y))


def minkowski_gradient(theta, x_set):
  res = 0
  for x_i in x_set:
    res += -(hyperboloid_dist(theta, x_i) * (minkowski_dot(theta, x_i)**2 - 1)**(-1/2) ) * x_i
  res = res*2/(len(x_set))
  return res


def hyperboloid_gradient(theta, x_set):
  mink_grad = minkowski_gradient(theta, x_set)
  res = mink_grad + minkowski_dot(theta, mink_grad) * theta
  if minkowski_dot(res, res) < 10e-16:
    res = np.zeros(theta.shape)
    res.fill(10e-16)
  return res

# la norma non deve essere quella euclidea ma quella riemanniana
# da cio dobbiamo evitare errori di calcolo nel gradiente poiche potrebbe non essere 
def hyperboloid_exp(theta, v):
  # return np.cosh(math.sqrt(np.dot(v, v)))*theta + np.sinh(math.sqrt(np.dot(v, v)))*(v/math.sqrt(np.dot(v, v)))
  return np.cosh(math.sqrt(minkowski_dot(v, v)))*theta + np.sinh(math.sqrt(minkowski_dot(v, v)))*(v/math.sqrt(minkowski_dot(v, v)))


def hyperboloid_log(theta_1, theta_2):
  #tmp = theta_2-minkowski_dot(theta_1, theta_2)*theta_1
  #return hyperboloid_dist(theta_1, theta_2)*(tmp)/(np.dot(tmp, tmp)**(1/2))
  alpha = -minkowski_dot(theta_1, theta_2)
  return (np.arccosh(alpha)/((alpha**2 - 1)**(1/2)))*(theta_2 - alpha*theta_1)

def hyperboloid_transport(theta_1, theta_2, v):
  return v # identity transport
  # return v - (minkowski_dot(hyperboloid_log(theta_1, theta_2), v)/hyperboloid_dist(theta_1, theta_2)**2)*(hyperboloid_log(theta_1, theta_2) + hyperboloid_log(theta_2, theta_1))

def frechet_mean(theta, x_set, distance):
  sum_ = 0
  s = len(x_set)
  for x_i in x_set:
    sum_ += distance(theta, x_i)**2
  return sum_/s

def poincare_points_factory(norm=1):
  # non √® uniforme nel disco di poincar√©, ma √® piu vicino al centro
  z = random()
  t = random()*2*math.pi
  return np.array([z*np.cos(t), z*np.sin(t)])


def rho(x):
  return x[:-1]/(x[-1]+1)


def inv_rho(y):
  r = np.dot(y,y)
  return np.array(np.append(y[:],[(1+r)/2]))*2/(1-r) 


def plot_alg(seq, x_set, ax):
  x = np.linspace(-1.0, 1.0, 100)
  y = np.linspace(-1.0, 1.0, 100)
  X, Y = np.meshgrid(x,y)
  F = X**2 + Y**2 - 1
  ax.contour(X,Y,F,[0])

  seq = np.array(seq)
  x_set = np.array(x_set)

  ax.scatter(seq[:, 0], seq[:, 1], c="red", marker="x")
  ax.scatter(seq[-1, 0], seq[-1, 1], c="green", marker="^")
  ax.scatter(x_set[:, 0], x_set[:, 1], c="blue", marker="o")


def poincare_dist_mpf(x, y):
  return acosh(1 + 2*(np.dot(x-y, x-y)/((1-np.dot(x,x))*(1-np.dot(y,y)))))


def convergence_seq(psi_seq, limit):
  return [poincare_dist_mpf(psi, limit) for psi in psi_seq]
  # return [LA.norm(psi - limit) for psi in psi_seq] # euclidean norm


# TODO: sostituire norma euclidea con variabile a seconda del metodo del calcolo
# del gradiente
def plot_seq(psi_seq, f_seq, g_seq, limit, dimm):
  fig = plt.figure(figsize=[12.8, 12.8])
  fig.clf()
  gs = fig.add_gridspec(2, 2)
  ax1 = fig.add_subplot(gs[0, 0])
  ax1.title.set_text("poincar√© ball over complexes (R^2)")
  ax2 = fig.add_subplot(gs[1, 0])
  ax2.title.set_text("error sequence")
  ax3 = fig.add_subplot(gs[0, 1])
  ax3.title.set_text("f sequence")
  ax4 = fig.add_subplot(gs[1, 1])
  ax4.title.set_text("g-norm sequence")

  if dim == 2:
    plot_alg(psi_seq, x_set, ax1)
  conv_seq = convergence_seq(psi_seq, limit)
  ax2.semilogy(conv_seq)
  ax3.semilogy(f_seq)
  g_norm = [LA.norm(g) for g in g_seq]
  ax4.semilogy((g_norm))

"""# Cariamento dei dati"""

#x_set = [poincare_points_factory() for _ in range(4)]
x_set = np.array([[-0.5, 0], [0.3, 0], [0.6, 0]], dtype=np.float64)

def generate_starting_point(x_set):
    psi_0 = np.zeros(x_set.shape[1]) # poincare_points_factory() # calcolare come media dei punti x_set
    for a_i in x_set:
      psi_0 += a_i
    psi_0 /= len(x_set)
    return psi_0

def generate_sets_from_file(file_name="points.txt"):
  x_set_s = []
  with open(file_name, "r") as f:
    for line in f.readlines():
      line_els = line.split(",")
      dim = int(line_els[0])
      limit = [mpf(i) for i in line_els[-dim:]]
      x_set = []
      for i in range(1, len(line_els)-dim, dim):
        x_set.append([float(i) for i in line_els[i:i+dim]])
      x_set = np.array(x_set)
      x_set_s.append((dim, x_set, limit))
  return x_set_s

x_set_s = generate_sets_from_file()

print(x_set_s)

dim, x_set, limit = x_set_s[2]
psi_0 = generate_starting_point(x_set)

print(dim)
print(x_set)
print(psi_0)
print(limit)

"""# Metodo iterativo

parte da un punto a_i e si va nella direzione del secondo seguendo la geodedica e ci si ferma ad 1/2 poi si va verso il terzo punto e si prosegue per 1/3 poi si va verso il quarto putno e si prosegue per 1/4 e cosi via. x_k+1 = exp(log(x_k, a_(k%p)), 1/k); p = # punti.  
converge al baricentro
"""

def iterative_method_poincare(x_set, max_steps=10):
  m = len(x_set)
  x_k = x_set[0]
  for i in range(1, max_steps):
    j = (i)%m
    a_j = x_set[j]
    x_k = poincare_exp(x_k, poincare_log(x_k, a_j)/(i+1))
  return x_k

def iterative_method_hyperboloid(x_set, max_steps=10):
  m = len(x_set)
  x_k = x_set[0]
  for i in range(1, max_steps):
    j = (i)%m
    a_j = x_set[j]
    x_k = hyperboloid_exp(x_k, hyperboloid_log(x_k, a_j)/(i+1))
  return x_k

limit_iter = iterative_method_poincare(x_set, 100000)
print(limit_iter)

limit_iter = rho(iterative_method_hyperboloid([inv_rho(x) for x in x_set], 100000))
print(limit_iter)

"""# Optimisations Algorithms


"""

def C_complex(z): # trasformata di Cayley
  return (1-z)/(1+z)


def C(a): # wrapper trasformata di Cayley
  z = np.complex(a[0], a[1])
  ret = C_complex(z)
  return np.array([ret.real, ret.imag])


def direct_g(a_set):
  return C_complex(np.prod([C_complex(np.complex(a[0], a[1])) for a in a_set])**(1/len(a_set)))


direct_g(x_set)

"""## Algoritmo Per il baricentro di riferimento"""

from math import exp

# IANNAZZO IMPLEMENTATION
def poincare_points_factory_complex(norm=1):
  # non √® uniforme nel disco di poincar√©, ma √® piu vicino al centro
  z = random()
  t = random()*2*math.pi
  return np.complex(z*np.cos(t),z*np.sin(t))


def complex_sign(z: complex) -> complex:
  if z==0:
    return 1
  return z/np.absolute(z)


def poincare_tangent_complex(a: complex, b: complex) -> complex:
  s = (b-a)/(1-a.conjugate()*b)
  v = complex_sign(s) *(1-np.absolute(a)**2)
  v = v*np.arctanh(np.absolute(s))
  return v


def poincare_geodesic_complex(x: complex, v: complex, t: float) -> complex:
  tmp = 2*np.absolute(v)/(1-np.absolute(x)**2)
  num = (x+(complex_sign(v)))+(x-(complex_sign(v)))*exp(-tmp*t)
  den = (1+x.conjugate()*(complex_sign(v)))+(1-x.conjugate()*(complex_sign(v)))*exp(-tmp*t)
  return num/den


def r2_to_complex_array(points):
  return [np.complex(a[0], a[1]) for a in points]

def complex_to_r2_array(points):
  return [np.array([z.real, z.imag]) for z in points]

# implemento algoritmi del professor iannazzo come riferimento per il calcolo
# del baricentro
def poincare_barycenter_iannazzo(data, par, maxit=100):
  x0 = 0
  psi_seq = [x0]
  m = len(data)
  for k in range(m):
    x0=x0+data[k]/m

  for h in range(maxit):
    incr=0
    for k in range(m):
      ai=data[k]
      incr=incr+poincare_tangent_complex(x0,ai)
    x1=poincare_geodesic_complex(x0, incr, par)
    if np.absolute(x1-x0)<10e-15:
      break
    psi_seq.append(x0)
    x0=x1
  return psi_seq


def plot_psi_seq(psi_seq, limit, dim):
  fig = plt.figure(figsize=[6.4, 12.8])
  fig.clf()
  gs = fig.add_gridspec(2, 1)
  ax1 = fig.add_subplot(gs[0, 0])
  ax1.title.set_text("poincar√© ball over complexes (R^2)")
  ax2 = fig.add_subplot(gs[1, 0])
  ax2.title.set_text("error sequence")

  if dim == 2:
    plot_alg(psi_seq, x_set, ax1)
  conv_seq = convergence_seq(psi_seq, limit)
  ax2.semilogy(conv_seq)

print(limit)

x_set_complex = r2_to_complex_array(x_set)
seq = poincare_barycenter_iannazzo(x_set_complex, 0.1, 1000)
seq = complex_to_r2_array(seq)
print("Limit sequence poincare: ", seq[-1])
plot_psi_seq(seq, limit, dim)

"""## Fixed Length step size"""

import math

def optimisation_fl_poincare(psi_0, learning_rate, x_set, max_steps=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  for i in range(max_steps):
    psi = psi_seq[-1]
    g = frechet_mean_poincare_grad(psi, x_set)
    if np.isnan(g).any():
      psi_seq = psi_seq[:-1]
      break
    if (g==0).any():
      break
    new_psi=poincare_exp(psi, -learning_rate*g)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g)
  return psi_seq, f_seq, g_seq


def optimisation_fl_poincare_euclidean(psi_0, learning_rate, x_set, max_steps=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  for i in range(max_steps):
    psi = psi_seq[-1]
    g = frechet_mean_poincare_grad_euclidean(psi, x_set)
    if np.isnan(g).any():
      psi_seq = psi_seq[:-1]
      break
    if (g==0).any():
      break
    new_psi=poincare_exp(psi, -learning_rate*g)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g)
  return psi_seq, f_seq, g_seq


def optimisation_fl_hyperboloid(psi_0, learning_rate, x_set, max_steps=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []
  x_set_h = [inv_rho(x_i) for x_i in x_set]

  for i in range(max_steps):
    psi = psi_seq[-1]
    theta=inv_rho(psi)
    g_h = hyperboloid_gradient(theta, x_set_h)
    if np.isnan(g_h).any():
      psi_seq = psi_seq[:-1]
      break
    if (g_h==0).any():
      break
    new_theta = hyperboloid_exp(theta, -learning_rate*g_h)
    new_psi = rho(new_theta)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g_h)
  return psi_seq, f_seq, g_seq

psi_seq, f_seq, g_seq = optimisation_fl_poincare(psi_0, 0.01, x_set, 100)
print("Limit sequence poincare: ", psi_seq[-1])
print(psi_seq)
plot_seq(psi_seq, f_seq, g_seq, limit, dim)

psi_seq, f_seq, g_seq = optimisation_fl_poincare_euclidean(psi_0, 0.0001, x_set, 100)
print("Limit sequence poincare euclideo: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq, limit, dim)

psi_seq, f_seq, g_seq = optimisation_fl_hyperboloid(psi_0, 0.4, x_set, 100)
print("Limit sequence iperboloide: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq, limit, dim)

"""### Armijo"""

def armijo_step_hiper_riemannian(theta, x_set_h, g_k, sigma, gamma, lambda_):
  h = 0
  while frechet_mean(hyperboloid_exp(theta, -(sigma**h)*lambda_*g_k), x_set_h, hyperboloid_dist) > frechet_mean(theta, x_set_h, hyperboloid_dist) - gamma*(sigma**h)*lambda_*minkowski_dot(g_k, g_k):
    h += 1
  return h

def armijo_opt_hiper_riemannian(psi_0, x_set, sigma, gamma, lambda_, max_iter=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []
  x_set_h = [inv_rho(x) for x in x_set]

  for k in range(max_iter):
    theta = inv_rho(psi_seq[-1])
    g_k = hyperboloid_gradient(theta, x_set_h)
    if np.isnan(g_k).any():
      psi_seq = psi_seq[:-1]
      break
    if (g_k==0).any():
      break
    h_k = armijo_step_hiper_riemannian(theta, x_set_h, g_k, sigma, gamma, lambda_)
    new_theta = hyperboloid_exp(theta, -(sigma**h_k)*lambda_*g_k)
    new_psi = rho(new_theta)
    
    psi_seq.append(rho(new_theta))
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g_k)
  return psi_seq, f_seq, g_seq

def armijo_step_poincare_riemannian(psi, x_set, g_k, sigma, gamma, lambda_):
  h = 0
  while frechet_mean(poincare_exp(psi, -(sigma**h)*lambda_*g_k), x_set, poincare_dist) > frechet_mean(psi, x_set, poincare_dist) + gamma*(sigma**h)*lambda_*(lambda_x(psi)**2*np.dot(g_k, -g_k)):
    h += 1
  return h

def armijo_opt_poincare_riemannian(psi_0, x_set, sigma, gamma, lambda_, max_iter=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  for k in range(max_iter):
    psi = psi_seq[-1]
    g_k = frechet_mean_poincare_grad(psi, x_set)
    if np.isnan(g_k).any():
      psi_seq = psi_seq[:-1]
      break
    if (g_k==0).any():
      break
    h_k = armijo_step_poincare_riemannian(psi, x_set, g_k, sigma, gamma, lambda_)
    new_psi = poincare_exp(psi, -(sigma**h_k)*lambda_*g_k)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g_k)
  return psi_seq, f_seq, g_seq

def armijo_step_poincare_euclidean(psi, x_set, g_k, d_k, sigma, gamma, lambda_):
  h = 0
  while frechet_mean(poincare_exp(psi, (sigma**h)*lambda_*d_k), x_set, poincare_dist) > frechet_mean(psi, x_set, poincare_dist) + gamma*(sigma**h)*lambda_*np.dot(g_k, d_k):
    h += 1
  return h

def armijo_opt_poincare_euclidean(psi_0, x_set, sigma, gamma, lambda_, max_iter=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  for k in range(max_iter):
    psi = psi_seq[-1]
    g_k = frechet_mean_poincare_grad_euclidean(psi, x_set)
    if np.isnan(g_k).any():
      psi_seq = psi_seq[:-1]
      break
    if (g_k==0).any():
      break
    d_k = -g_k
    h_k = armijo_step_poincare_euclidean(psi, x_set, g_k, d_k, sigma, gamma, lambda_)
    new_psi = poincare_exp(psi, (sigma**h_k)*lambda_*d_k)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g_k)
  return psi_seq, f_seq, g_seq

psi_seq, f_seq, g_seq = armijo_opt_poincare_euclidean(psi_0, x_set, 0.3, 0.001, 0.01, 100)
print("Limit sequence poincare euclidean: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq, limit, dim)

psi_seq, f_seq, g_seq = armijo_opt_poincare_riemannian(psi_0, x_set, 0.01, 0.001, 0.1, 100)
print("Limit sequence poincare: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq, limit, dim)

psi_seq, f_seq, g_seq = armijo_opt_hiper_riemannian(psi_0, x_set, 0.3, 0.1, 0.7, 100)
print("Limit sequence iperboloide: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq, limit, dim)

"""### Barzilai-Borwein"""

def RBB_hyperboloid(psi_0, x_set, a_min, a_max, max_steps=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  x_set_h = [inv_rho(x_i) for x_i in x_set]
  theta_0 = inv_rho(psi_0)

  f_k_seq = []

  a_BB = a_min
  for k in range(max_steps):
    theta = inv_rho(psi_seq[-1])
    g_k = hyperboloid_gradient(theta, x_set_h)
    f_k_seq.append(frechet_mean(theta, x_set_h, hyperboloid_dist))
    a_k = a_BB
    new_theta = hyperboloid_exp(theta, -a_k*g_k)
    new_psi = rho(new_theta)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g_k)

    new_f = frechet_mean(new_theta, x_set_h, hyperboloid_dist)
    new_g = hyperboloid_gradient(new_theta, x_set_h)
    s_k = -a_k*hyperboloid_transport(theta, new_theta, g_k)
    y_k = new_g + s_k/a_k

    if minkowski_dot(s_k, y_k) > 0:
      new_tau = minkowski_dot(s_k, s_k)/minkowski_dot(s_k, y_k)
      a_BB = min(a_max, max(a_min, new_tau))
    else:
      a_BB = a_max
      
  return psi_seq, f_seq, g_seq

def BB_poincare(psi_0, x_set, a_min, a_max, max_steps=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []


  a_BB = a_min
  for k in range(max_steps):
    psi = psi_seq[-1]
    g_k = frechet_mean_poincare_grad_euclidean(psi, x_set)
    f_k = frechet_mean(psi, x_set, poincare_dist)
    a_k = a_BB
    new_psi = poincare_exp(psi, -a_k*g_k)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g_k)

    new_f = frechet_mean(new_psi, x_set, poincare_dist)
    new_g = frechet_mean_poincare_grad(new_psi, x_set)
    s_k = -a_k*poincare_transport(psi, new_psi, g_k)
    y_k = new_g + s_k/a_k

    if np.dot(s_k, y_k) > 0:
      new_tau = np.dot(s_k, s_k)/np.dot(s_k, y_k)
      a_BB = min(a_max, max(a_min, new_tau))
    else:
      a_BB = a_max
  return psi_seq, f_seq, g_seq

def RBB_poincare(psi_0, x_set, a_min, a_max, max_steps=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  f_k_seq = []

  a_BB = a_min
  for k in range(max_steps):
    psi = psi_seq[-1]
    g_k = frechet_mean_poincare_grad(psi, x_set)
    f_k_seq.append(frechet_mean(psi, x_set, poincare_dist))
    a_k = a_BB
    new_psi = poincare_exp(psi, -a_k*g_k)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, poincare_dist))
    g_seq.append(g_k)

    new_f = frechet_mean(new_psi, x_set, poincare_dist)
    new_g = frechet_mean_poincare_grad(new_psi, x_set)
    s_k = -a_k*poincare_transport(psi, new_psi, g_k)
    y_k = new_g + s_k/a_k

    if lambda_x(new_psi)**2*np.dot(s_k, y_k) > 0:
      new_tau = lambda_x(new_psi)**2*np.dot(s_k, s_k)/(lambda_x(new_psi)**2*np.dot(s_k, y_k))
      a_BB = min(a_max, max(a_min, new_tau))
    else:
      a_BB = a_max
  return psi_seq, f_seq, g_seq

psi_seq, f_seq, g_seq = BB_poincare(psi_0, x_set, 0.0001, 0.01, 100)
print("Limit sequence poincare euclidean: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq, limit, dim)

psi_seq, f_seq, g_seq = RBB_poincare(psi_0, x_set, 0.0001, 0.9, 100)
print("Limit sequence poincare: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq, limit, dim)

# supporta un learnign rate piu alto convergendo in modo piu veloce
psi_seq, f_seq, g_seq = RBB_hyperboloid(psi_0, x_set, 0.001, 0.9, 100)
print("Limit sequence iperboloide: ", psi_seq[-1])
plot_seq(psi_seq, f_seq, g_seq, limit, dim)