# -*- coding: utf-8 -*-
"""HyperbolicPoincareRiemannianOpt2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1c-PIt39bQtTakWVp5Jf1Kv1UR26mfHQT

# Import
"""

import numpy as np
from random import random
import math
from itertools import compress

import matplotlib.pyplot as plt
from numpy import linalg as LA
import numpy.linalg as la
from sklearn.linear_model import HuberRegressor
from sklearn.preprocessing import StandardScaler

!pip install git+https://github.com/pymanopt/pymanopt
import pymanopt
from pymanopt.manifolds.manifold import Manifold

"""# Poincare"""

class PoincareBall(Manifold):
    def __init__(self, n, k):
        self.k = k
        self.n = n
        self.dimension = k*n
        super().__init__(
            "{} PoincareBall over R^{}".format(self.k, self.n), self.dimension,
            )
        
    def _squeeze(self, X):
        if self.k == 1 and len(X.shape) > 1:
            return np.squeeze(X, axis=1)
        else:
            return X

    def _pack(self, X):
        if len(X.shape) == 1:
            return np.expand_dims(X, axis=1)
        else:
            return X

    def conformal_factor(self, X):
        return 2/(1 - np.sum(X*X, axis=0))

    def mobius_add(self, X, Y):
        X = self._pack(X)
        Y = self._pack(Y)
        x_dot_y = np.sum(X*Y, axis=0)
        x_norm_q = np.sum(X*X, axis=0)
        y_norm_q = np.sum(Y*Y, axis=0)

        num = (1 + 2*x_dot_y + y_norm_q)*X + (1 - x_norm_q)*Y
        
        den = 1 + 2*x_dot_y + x_norm_q*y_norm_q

        return self._squeeze(num/den)

    def typicaldist(self):
        return self.dim / 8

    def inner(self, X, G, H):
        X = self._pack(X)
        G = self._pack(G)
        H = self._pack(H)
        return sum(np.sum(G*H, axis=0) * self.conformal_factor(X)**2)

    def proj(self, X, G):
        # Identity map since the embedding space is the tangent space R^n
        return self._squeeze(G)

    def norm(self, X, G):
        return math.sqrt(self.inner(X, G, G))

    def rand(self):
        isotropic = np.random.standard_normal(size=(self.n, self.k))
        isotropic = isotropic / la.norm(isotropic, axis=0)
        radius = np.random.rand(self.k) ** (1 / self.n)
        x = isotropic * radius
        return self._squeeze(x)

    def randvec(self, X):
        X = self._pack(X)
        v = np.random.rand(self.n, self.k)
        v = v / self.norm(X, v)
        return self._squeeze(v)

    def zerovec(self, X):
        return np.zeros(X.shape)

    def dist(self, X, Y):
        X = self._pack(X)
        Y = self._pack(Y)
        norms2x = np.sum(X*X, axis=0)
        norms2y = np.sum(Y*Y, axis=0)
        norms2diff = np.sum((X - Y)*(X - Y), axis=0)
        #a = max(
        #    1,
        #    1 + 2*(norms2diff / ((1-norms2x)*(1-norms2y))),
        #   )
        return math.sqrt(np.sum(np.arccosh(1 + 2*(norms2diff / ((1-norms2x)*(1-norms2y))))**2))

    def egrad2rgrad(self, X, G):
        X = self._pack(X)
        G = self._pack(G)
        factor_q = self.conformal_factor(X)**2
        return self._squeeze(G/factor_q)

    def ehess2rhess(self, X, G, H, U):
        X = self._pack(X)
        G = self._pack(G)
        H = self._pack(H)
        U = self._pack(U)
        factor = self.conformal_factor(X)
        return self._squeeze((U * np.sum(G*X, axis=0) - G * np.sum(U*X, axis=0)
                - X * np.sum(U*G, axis=0) + H/factor)/factor)

    def retr(self, X, U):
        return self.exp(X, U)

    def exp(self, X, U):
        X = self._pack(X)
        U = self._pack(U)
        norm_u = la.norm(U, axis=0)
        factor = (1 - np.sum(X*X, axis=0))
        # avoid division by 0
        tmp = np.tanh(norm_u/factor) * (U/((norm_u + (norm_u == 0))))
        return self.mobius_add(X, tmp)

    def log(self, X, Y):
        X = self._pack(X)
        Y = self._pack(Y)
        a = self.mobius_add(-X, Y)
        b = la.norm(a, axis=0)

        factor = 1 - np.sum(X*X, axis=0)
        return self._squeeze(a * factor * np.arctanh(b) / b)

    def transp(self, X1, X2, G):
        return G

    def pairmean(self, X, Y):
        return self.exp(X, self.log(X, Y) / 2)

"""# Hyperboloid"""

class Hyperboloid(Manifold):
    def __init__(self, n, k):
        self.n = n
        self.k = k
        self.dimension = n * k
        super().__init__(
            "{} Hyperboloid over R^{}:1".format(k, n), self.dimension,
            )

    def _squeeze(self, X):
        if self.k == 1 and len(X.shape) > 1:
            return np.squeeze(X, axis=1)
        else:
            return X

    def _pack(self, X):
      if len(X.shape) == 1:
        return np.expand_dims(X, axis=1)
      else:
        return X

    def inner_minkowski_columns(self, U, V):
        U = self._pack(U)
        V = self._pack(V)
        return self._squeeze(np.array(
              [
                  np.dot(U[:, i][:-1], V[:, i][:-1]) - U[:, i][-1]*V[:, i][-1]
                  for i in range(self.k)
              ]
              ))

    def typicaldist(self):
        return math.sqrt(self.dim)

    def inner(self, X, U, V):
        U = self._pack(U)
        V = self._pack(V)
        return np.sum(self.inner_minkowski_columns(U, V))

    def proj(self, X, G):
        X = self._pack(X)
        G = self._pack(G)
        inners = self.inner_minkowski_columns(X, G)
        return self._squeeze(G + X*inners)

    def norm(self, X, G):
        return math.sqrt(max(0, self.inner(X, G, G)))

    def rand(self):
        ret = np.zeros((self.n+1, self.k))
        x0 = np.random.normal(size=(self.n, self.k))
        x1 = np.sqrt(1 + np.sum(x0 * x0, axis=0))
        ret[:-1, :] = x0
        ret[-1, :] = x1
        return self._squeeze(ret)

    def randvec(self, X):
        X = self._pack(X)
        U = self.proj(X, np.random.rand(X.shape))
        return self._squeeze(U / self.norm(X, U))

    def zerovec(self, X):
        return np.zeros(X.shape)

    def _dists(self, X, Y):
        X = self._pack(X)
        Y = self._pack(Y)
        alpha = -self.inner_minkowski_columns(X, Y)
        alpha[alpha < 1] = 1
        return np.arccosh(alpha)

    def dist(self, X, Y):
        X = self._pack(X)
        Y = self._pack(Y)
        return self._squeeze(la.norm(self._dists(X, Y)))

    def egrad2rgrad(self, X, G):
        X = self._pack(X)
        G = self._pack(G)
        G[-1, :] = -G[-1, :]
        return self.proj(X, G)

    def ehess2rhess(self, X, G, H, U):
        X = self._pack(X)
        G = self._pack(G)
        H = self._pack(H)
        U = self._pack(U)
        G[-1, :] = -G[-1, :]
        H[-1, :] = -H[-1, :]
        inners = self.inner_minkowski_columns(X, G)
        return self.proj(X, U*inners + H)

    def retr(self, X, U):
        X = self._pack(X)
        U = self._pack(U)
        return self._squeeze(self.exp(X, U))

    def exp(self, X, U):
        X = self._pack(X)
        U = self._pack(U)
        # compute the individual minkowski norm for each individual column of U
        mink_inners = self.inner_minkowski_columns(U, U)
        vnormmf = np.vectorize(lambda x: math.sqrt(max(0, x)))
        mink_norms = vnormmf(mink_inners)
        a = np.sinh(mink_norms)/mink_norms
        a[np.isnan(a)] = 1
        return self._squeeze(np.cosh(mink_norms)*X + U*a)

    def log(self, X, Y):
        X = self._pack(X)
        Y = self._pack(Y)
        d = self._dists(X, Y)
        a = d/np.sinh(d)
        a[np.isnan(a)] = 1
        return self._squeeze(self.proj(X, Y*a))

    def transp(self, X1, X2, G):
        X1 = self._pack(X1)
        X2 = self._pack(X2)
        G = self._pack(G)
        return self._squeeze(self.proj(X2, G))

    def pairmean(self, X, Y):
        X = self._pack(X)
        Y = self._pack(Y)
        return self._squeeze(self.exp(X, self.log(X, Y), 1/2))

"""# Derivate of the loss function"""

# --- Poincare Gradiend
def poincare_dist_grad(x, y):
  a = 1 - np.dot(x, x)
  b = 1 - np.dot(y, y)
  c = 1 + (2/(a*b))*(np.dot(x-y, x-y))
  
  return 4/(b*math.sqrt(c**2-1))*(((np.dot(y,y) - 2*np.dot(x, y) + 1)/(a**2))*x - y/a)


def frechet_mean_poincare_grad(psi, x_set, manifold):
  res = 0
  for x_i in x_set:
    res += manifold.dist(psi, x_i)*poincare_dist_grad(psi, x_i)
  return res*2/(len(x_set))


def frechet_mean_poincare_rgrad(psi, x_set, manifold):
  egrad = frechet_mean_poincare_grad(psi, x_set, manifold)
  return PoincareManifold.egrad2rgrad(psi, egrad)


# --- Hyperboloid Gradient
def frechet_mean_hyperboloid_grad(theta, x_set, manifold):
  res = 0
  for x_i in x_set:
    x_i_g = x_i.copy()
    x_i_g[-1] = -x_i_g[-1] # gradiente euclideo di prodotto di minkowski
    res += -(manifold.dist(theta, x_i) * (manifold.inner_minkowski_columns(theta, x_i)**2 - 1)**(-1/2)) * x_i_g
  res = res*2/(len(x_set))
  return res


def frechet_mean_hyperboloid_rgrad(theta, x_set, manifold):
  egrad = frechet_mean_hyperboloid_grad(theta, x_set, manifold)
  return HyperboloidManifold.egrad2rgrad(theta, egrad)


def frechet_mean(theta, x_set, distance):
  sum_ = 0
  s = len(x_set)
  for x_i in x_set:
    sum_ += distance(theta, x_i)**2
  return sum_/s

def rho(x):
  return x[:-1]/(x[-1]+1)


def inv_rho(y):
  r = np.dot(y,y)
  return np.array(np.append(y[:],[(1+r)/2]))*2/(1-r) 


def plot_alg(seq, x_set, ax):
  x = np.linspace(-1.0, 1.0, 100)
  y = np.linspace(-1.0, 1.0, 100)
  X, Y = np.meshgrid(x,y)
  F = X**2 + Y**2 - 1
  ax.contour(X,Y,F,[0])

  seq = np.array(seq)
  x_set = np.array(x_set)

  ax.scatter(seq[:, 0], seq[:, 1], c="red", marker="x")
  ax.scatter(seq[-1, 0], seq[-1, 1], c="green", marker="^")
  ax.scatter(x_set[:, 0], x_set[:, 1], c="blue", marker="o")


def poincare_dist(x, y):
  return np.arccosh(1 + 2*(np.dot(x-y, x-y)/((1-np.dot(x,x))*(1-np.dot(y,y)))))


def convergence_seq(psi_seq, limit):
  return [poincare_dist(psi, limit) for psi in psi_seq]


def plot_seq(x_set, psi_seq, f_seq, g_seq, limit, dim):
  fig = plt.figure(figsize=[12.8, 12.8])
  fig.clf()
  gs = fig.add_gridspec(2, 2)
  ax1 = fig.add_subplot(gs[0, 0])
  ax1.title.set_text("poincarÃ© ball over complexes (R^2)")
  ax2 = fig.add_subplot(gs[1, 0])
  ax2.title.set_text("error sequence")
  ax3 = fig.add_subplot(gs[0, 1])
  ax3.title.set_text("f sequence")
  ax4 = fig.add_subplot(gs[1, 1])
  ax4.title.set_text("g-norm sequence")

  if dim == 2:
    plot_alg(psi_seq, x_set, ax1)
  conv_seq = convergence_seq(psi_seq, limit)
  ax2.semilogy(conv_seq)
  ax3.semilogy(f_seq)
  g_norm = [LA.norm(g) for g in g_seq]
  ax4.semilogy((g_norm))

"""# Optimization Algorithms

## Fixed Lenght Step Size
"""

def optimisation_fl_poincare(psi_0, f_grad, x_set, learning_rate, max_steps=10, limited=True):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  k = 0

  while True:
    psi = psi_seq[-1]
    g = f_grad(psi, x_set, PoincareManifold)

    if LA.norm(g) < 10e-10:
      break

    if np.isnan(g).any():
      psi_seq = psi_seq[:-1]
      break

    new_psi=PoincareManifold.exp(psi, -learning_rate*g)


    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, PoincareManifold.dist))
    g_seq.append(g)

    # forced exit condition
    k = k+1
    if limited and k >= max_steps:
      break
    
  return psi_seq, f_seq, g_seq


def optimisation_fl_hyperboloid(psi_0, f_grad, x_set, learning_rate, max_steps=10, limited=True):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []
  x_set_h = [inv_rho(x_i) for x_i in x_set]

  k=0

  while True:
    psi = psi_seq[-1]
    theta=inv_rho(psi)
    g_h = f_grad(theta, x_set_h, HyperboloidManifold)

    if LA.norm(g_h) < 10e-10:
      break
    
    if np.isnan(g_h).any():
      psi_seq = psi_seq[:-1]
      break
    
    new_theta = HyperboloidManifold.exp(theta, -learning_rate*g_h)
    new_psi = rho(new_theta)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, PoincareManifold.dist))
    g_seq.append(g_h)

    # forced exit condition
    k = k+1
    if limited and k >= max_steps:
      break

  return psi_seq, f_seq, g_seq

"""## Armijo"""

def armijo_step_riemannian(manifold, theta, x_set, g_k, sigma, gamma, lambda_):
  h = 0
  while frechet_mean(manifold.exp(theta, -(sigma**h)*lambda_*g_k), x_set, manifold.dist) > frechet_mean(theta, x_set, manifold.dist) + gamma*(sigma**h)*lambda_*manifold.inner(theta, g_k, -g_k):
    h += 1
  return h

def armijo_hyperboloid(psi_0, f_grad, x_set, sigma, gamma, lambda_, max_steps=10):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []
  x_set_h = [inv_rho(x) for x in x_set]

  k = 0

  while True:
    theta = inv_rho(psi_seq[-1])
    g_k = f_grad(theta, x_set_h, HyperboloidManifold)
    if np.isnan(g_k).any():
      psi_seq = psi_seq[:-1]
      break
    if LA.norm(g_k) < 10e-10:
      break
    h_k = armijo_step_riemannian(HyperboloidManifold, theta, x_set_h, g_k, sigma, gamma, lambda_)
    new_theta = HyperboloidManifold.exp(theta, -(sigma**h_k)*lambda_*g_k)
    new_psi = rho(new_theta)
    
    psi_seq.append(rho(new_theta))
    f_seq.append(frechet_mean(new_psi, x_set, PoincareManifold.dist))
    g_seq.append(g_k)

    # forced exit condition
    k = k+1
    if k >= max_steps:
      break
  return psi_seq, f_seq, g_seq


def armijo_poincare(psi_0, f_grad, x_set, sigma, gamma, lambda_, max_steps=10):  
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  k = 0

  while True:
    psi = psi_seq[-1]
    g_k = f_grad(psi, x_set, PoincareManifold)
    if np.isnan(g_k).any():
      psi_seq = psi_seq[:-1]
      break
    if LA.norm(g_k) < 10e-10:
      break
    h_k = armijo_step_riemannian(PoincareManifold, psi, x_set, g_k, sigma, gamma, lambda_)
    new_psi = PoincareManifold.exp(psi, -(sigma**h_k)*lambda_*g_k)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, PoincareManifold.dist))
    g_seq.append(g_k)

    # forced exit condition
    k = k+1
    if k >= max_steps:
      break

  return psi_seq, f_seq, g_seq

"""## Barzilai Borwain"""

def RBB_poincare(psi_0, f_grad, x_set, a_min, a_max, max_steps=100):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  a_BB = a_min

  k = 0

  g_k = f_grad(psi_0, x_set, PoincareManifold)
  while True:
    if LA.norm(g_k) < 10e-10:
      break

    psi = psi_seq[-1]

    a_k = a_BB
    new_psi = PoincareManifold.exp(psi, -a_k*g_k)
    new_g = f_grad(new_psi, x_set, PoincareManifold)

    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(psi, x_set, PoincareManifold.dist))
    g_seq.append(g_k)

    s_k = -a_k*PoincareManifold.transp(psi, new_psi, g_k)
    y_k = new_g + s_k/a_k

    tmp = PoincareManifold.inner(new_psi, s_k, y_k)
    if tmp > 0:
      new_tau = PoincareManifold.inner(new_psi, s_k, s_k)/(tmp)
      a_BB = min(a_max, max(a_min, new_tau))
    else:
      a_BB = a_max

    # forced exit condition
    k = k+1
    if k >= max_steps:
      break
    
    g_k = new_g

  return psi_seq, f_seq, g_seq


def RBB_hyperboloid(psi_0, f_grad, x_set, a_min, a_max, max_steps=100):
  psi_seq = [psi_0]
  f_seq = []
  g_seq = []

  x_set_h = [inv_rho(x_i) for x_i in x_set]
  theta_0 = inv_rho(psi_0)

  f_k_seq = []

  a_BB = a_min

  k = 0

  g_k = f_grad(theta_0, x_set_h, HyperboloidManifold)
  while True:
    if LA.norm(g_k) < 10e-10:
      break

    theta = inv_rho(psi_seq[-1])

    a_k = a_BB
    new_theta = HyperboloidManifold.exp(theta, -a_k*g_k)
    new_psi = rho(new_theta)
    new_g = f_grad(new_theta, x_set_h, HyperboloidManifold)
    
    psi_seq.append(new_psi)
    f_seq.append(frechet_mean(new_psi, x_set, PoincareManifold.dist))
    g_seq.append(g_k)
    
    s_k = -a_k*HyperboloidManifold.transp(theta, new_theta, g_k)
    y_k = new_g + s_k/a_k

    tmp = HyperboloidManifold.inner(new_psi, s_k, y_k)
    if tmp > 0:
      new_tau = HyperboloidManifold.inner(new_psi, s_k, s_k)/(tmp)
      a_BB = min(a_max, max(a_min, new_tau))
    else:
      a_BB = a_max

    # forced exit condition
    k = k+1
    if k >= max_steps:
      break

    g_k = new_g
      
  return psi_seq, f_seq, g_seq

"""# Loading and data creating"""

def generate_starting_point(x_set):
  psi_0 = np.zeros(x_set.shape[1]) # poincare_points_factory() # calcolare come media dei punti x_set
  for a_i in x_set:
    psi_0 += a_i
  psi_0 /= len(x_set)
  return psi_0


def parse_set_in_list(x_set):
  points = []
  for x in x_set:
    points += x.tolist()
  return points


def format_data_to_save(x_0, x_set, limit):
  dim = x_set.shape[1]
  points = parse_set_in_list(x_set)
  return [dim] + x_0.tolist() + points + limit.tolist()


def save_to_file(to_save_data, file_name="bunch.txt"):
  with open(file_name, "w") as f:
    for data in to_save_data:
      f.write(",".join(str(i) for i in data) + "\n")


def save_bunch_test_set(bunch_set):
  to_save = [format_data_to_save(x_0, x_set, limit) for (x_0, x_set, limit) in bunch_set]
  save_to_file(to_save)


def load_bunch_from_file(file_name="bunch.txt"):
  x_set_s = []
  dim = -1 # dimensione comune a tutto il dataset
  with open(file_name, "r") as f:
    for line in f.readlines():
      line_els = line.split(",")
      dim = int(line_els[0])
      limit = np.array([float(i) for i in line_els[-dim:]])
      x_0 = np.array([float(i) for i in line_els[1:dim+1]])
      x_set = []
      for i in range(dim+1, len(line_els)-dim, dim):
        x_set.append([float(i) for i in line_els[i:i+dim]])
      x_set = np.array(x_set)
      x_set_s.append((x_0, x_set, limit))
  return dim, x_set_s


def create_bunch_test_set(manifold, card_bunch=50, card_x=4):
  bunch_test_set = []
  for i in range(card_bunch):
    print(i/card_bunch * 100, "%")
    x_set = np.array([manifold.rand() for _ in range(card_x)])
    x_0 = generate_starting_point(x_set)
    # TODO: confrontarmi con il prof per il calcolo del limite
    psi_seq, _, _ = optimisation_fl_poincare(x_0, frechet_mean_poincare_rgrad, x_set, 0.001, 5000, False)
    limit = psi_seq[-1]
    bunch_test_set.append((x_0, x_set, limit))

  return bunch_test_set

#dim = 2
#PoincareManifold = PoincareBall(dim, 1)
#HyperboloidManifold = Hyperboloid(dim, 1)
#bunch = create_bunch_test_set(PoincareManifold, card_bunch=200, card_x=4)
#save_bunch_test_set(bunch)

dim, bunch = load_bunch_from_file()
PoincareManifold = PoincareBall(dim, 1)
HyperboloidManifold = Hyperboloid(dim, 1)

"""# Test Algorithms"""

def time_to_converge(seq, limit, iter_test, epsilon=10e-4):
  differences = []
  for s in seq:
    diff = s - limit
    differences.append(math.sqrt(np.dot(diff, diff)) < epsilon)
  time_conv = np.argmax(differences)
  if time_conv == 0:
    time_conv = iter_test
  return time_conv


def test_algorithm(algotithm_poincare, algorithm_hyperboloid, bunch_test_set, iter_test, figname, tollerance_outlier=0):
  a = []
  b = []

  for (x_0, x_set, limit) in bunch_test_set:
    seq_poincare, _, _ = algotithm_poincare(x_0, x_set, iter_test)
    a.append(time_to_converge(seq_poincare, limit, iter_test, 10e-6))
    seq_hyper, _, _ = algorithm_hyperboloid(x_0, x_set, iter_test)
    b.append(time_to_converge(seq_hyper, limit, iter_test, 10e-6))
    

  mean_conv_a = sum(a)/len(bunch_test_set)
  mean_conv_b = sum(b)/len(bunch_test_set)

  print("Mean convergence Disk:", mean_conv_a)
  print("Mean convergence Iperboloid:", mean_conv_b)

  ab = list(zip(a, b))
  z = [ab.count(i) for i in ab]
  filter = [z_i > tollerance_outlier for z_i in z]
  a_cutted = list(compress(a, filter))
  b_cutted = list(compress(b, filter))

  a_scaler, b_scaler = StandardScaler(), StandardScaler()
  a_train = a_scaler.fit_transform(np.array(a_cutted)[..., None])
  b_train = b_scaler.fit_transform(np.array(b_cutted)[..., None])

  model = HuberRegressor(epsilon=1)
  model.fit(a_train, b_train.ravel())

  ang_coef_lin, t = np.polyfit(a_cutted, b_cutted, 1)
  test_a = np.array([0, iter_test])
  predictions = b_scaler.inverse_transform(
      model.predict(a_scaler.transform(test_a[..., None]))
  )

  ang_coef_huber = (predictions[1] - predictions[0]) / (test_a[1] - test_a[0])

  print("SLOPE Huber Regressor:", ang_coef_huber)
  print("SLOPE Linear Regressor:", ang_coef_lin)
  plt.figure(figsize=(20, 20))
  plt.plot(test_a, ang_coef_lin*np.array(test_a) + t, 'y')
  plt.plot(test_a, predictions, 'r')
  plt.legend([f'Least Square Regression Line, ang. coeff. = {ang_coef_lin:.4f}', 
              f'Huber Regression Line, ang. coeff. = {ang_coef_huber:.4f}'],
             prop={'size': 20})

  plt.scatter(a, b, c=z)
  plt.colorbar()
  plt.xlabel("Step to Converge on Poincare Disk", fontsize=18)
  plt.ylabel("Step to Converge on Hyperboloid", fontsize=18)
  plt.savefig(figname)

def make_fl_curve(algorithm_poincare, algorithm_hyperbolid, X0, X, limit, iter_test, max_iter=100):
  sequence_poincare = []
  sequence_hyper = []

  for i in range(1, iter_test):
    poincare_seq, _, _= algorithm_poincare(X0, frechet_mean_poincare_rgrad, X, (i/iter_test), max_iter)
    min_poincare = time_to_converge(poincare_seq, limit, max_iter)
    sequence_poincare.append(min_poincare)
    hyper_seq, _, _ = algorithm_hyperbolid(X0, frechet_mean_hyperboloid_rgrad, X, (i/iter_test), max_iter)
    min_hyper = time_to_converge(hyper_seq, limit, max_iter)
    sequence_hyper.append(min_hyper)

  return np.array(sequence_poincare), np.array(sequence_hyper)


def test_one_parameter_optimization(algorithm_poincare, algorithm_hyperbolid, bunch_test_set, iter_test, max_iter=100):
  sequence_poincare = np.zeros(iter_test-1)
  sequence_hyper = np.zeros(iter_test-1)
  for (x_0, x_set, limit) in bunch_test_set:
    fl_poincare_curve, fl_hyper_curve = make_fl_curve(algorithm_poincare, algorithm_hyperbolid, x_0, x_set, limit, iter_test, max_iter)
    sequence_poincare += fl_poincare_curve
    sequence_hyper += fl_hyper_curve
  return sequence_poincare/len(bunch_test_set), sequence_hyper/len(bunch_test_set)

x_0, x_set, limit = bunch[0]
print("limit:", limit)

psi_seq, f_seq, g_seq = optimisation_fl_poincare(x_0, frechet_mean_poincare_rgrad, x_set, 0.20, 100)
print("Limit sequence poincare: ", psi_seq[-1])
print(psi_seq)
plot_seq(x_set, psi_seq, f_seq, g_seq, limit, dim)

psi_seq, f_seq, g_seq = optimisation_fl_hyperboloid(x_0, frechet_mean_hyperboloid_rgrad, x_set, 0.20, 100)
print("Limit sequence iperboloide: ", psi_seq[-1])
plot_seq(x_set, psi_seq, f_seq, g_seq, limit, dim)

psi_seq, f_seq, g_seq = armijo_poincare(x_0, frechet_mean_poincare_rgrad, x_set, 0.3, 0.001, 0.9, 100)
print("Limit sequence poincare: ", psi_seq[-1])
plot_seq(x_set, psi_seq, f_seq, g_seq, limit, dim)

psi_seq, f_seq, g_seq = armijo_hyperboloid(x_0, frechet_mean_hyperboloid_rgrad, x_set, 0.3, 0.001, 0.9, 100)
print("Limit sequence iperboloide: ", psi_seq[-1])
plot_seq(x_set, psi_seq, f_seq, g_seq, limit, dim)

psi_seq, f_seq, g_seq = RBB_poincare(x_0, frechet_mean_poincare_rgrad, x_set, 0.0001, 0.9, 100)
print("Limit sequence poincare: ", psi_seq[-1])
print(f_seq)
plot_seq(x_set, psi_seq, f_seq, g_seq, limit, dim)

psi_seq, f_seq, g_seq = RBB_hyperboloid(x_0, frechet_mean_hyperboloid_rgrad, x_set, 0.0001, 0.9, 100)
print("Limit sequence iperboloide: ", psi_seq[-1])
plot_seq(x_set, psi_seq, f_seq, g_seq, limit, dim)

sequence_fixed_lenght_poincare, sequence_fixed_lenght_hyper = test_one_parameter_optimization(
    optimisation_fl_poincare,
    optimisation_fl_hyperboloid,
    bunch[:20],
    100)

print(min(sequence_fixed_lenght_poincare))
alpha_D = (np.argmin(sequence_fixed_lenght_poincare)+1)/100
print(alpha_D)

plt.figure(figsize=(10,10))
plt.plot([i/100 for i in range(1, 100)], sequence_fixed_lenght_poincare)
plt.xlabel("parameter value", fontsize=18)
plt.ylabel("step to convergence", fontsize=18)
plt.savefig("fixed_step_parameter_poincare")

print(min(sequence_fixed_lenght_hyper))
alpha_H = (np.argmin(sequence_fixed_lenght_hyper)+1)/100
print(alpha_H)

plt.figure(figsize=(10,10))
plt.plot([i/100 for i in range(1, 100)], sequence_fixed_lenght_hyper)
plt.xlabel("parameter value", fontsize=18)
plt.ylabel("step to convergence", fontsize=18)
plt.savefig("fixed_step_parameter_hyperboloid")

sequence_armijo_poincare, sequence_armijo_hyper = test_one_parameter_optimization(
    lambda X0, rgrad, X, learning_rate, max_iter: armijo_poincare(X0, rgrad, X, 0.3, 0.001, learning_rate, max_iter),
    lambda X0, rgrad, X, learning_rate, max_iter: armijo_hyperboloid(X0, rgrad, X, 0.3, 0.001, learning_rate, max_iter),
    bunch[:10],
    100)

print(min(sequence_armijo_poincare))
lambda_D = (np.argmin(sequence_armijo_poincare)+1)/100
print(lambda_D)

plt.figure(figsize=(10,10))
plt.plot([i/100 for i in range(1, 100)], sequence_armijo_poincare)
plt.xlabel("parameter value", fontsize=18)
plt.ylabel("step to convergence", fontsize=18)
plt.savefig("armijo_parameter_poincare")

print(min(sequence_armijo_hyper))
lambda_H = (np.argmin(sequence_armijo_hyper)+1)/100
print(lambda_H)

plt.figure(figsize=(10,10))
plt.plot([i/100 for i in range(1, 100)], sequence_armijo_hyper)
plt.xlabel("parameter value", fontsize=18)
plt.ylabel("step to convergence", fontsize=18)
plt.savefig("armijo_parameter_hyperboloid")

test_algorithm(lambda X0, X, max_iter: optimisation_fl_poincare(X0, frechet_mean_poincare_rgrad, X, alpha_D, max_iter),
               lambda X0, X, max_iter: optimisation_fl_hyperboloid(X0, frechet_mean_hyperboloid_rgrad, X, alpha_H, max_iter),
               bunch,
               100,
               "fixed_step_size",
               5)

test_algorithm(lambda X0, X, max_iter: armijo_poincare(X0, frechet_mean_poincare_rgrad, X, 0.3, 0.001, lambda_D, max_iter),
               lambda X0, X, max_iter: armijo_hyperboloid(X0, frechet_mean_hyperboloid_rgrad, X, 0.3, 0.001, lambda_H, max_iter),
               bunch,
               100,
               "armijo",
               5)

test_algorithm(lambda X0, X, max_iter: RBB_poincare(X0, frechet_mean_poincare_rgrad, X, 0.0001, 0.9, max_iter),
               lambda X0, X, max_iter: RBB_hyperboloid(X0, frechet_mean_hyperboloid_rgrad, X, 0.0001, 0.9, max_iter),
               bunch,
               100,
               "barzilai_borwein",
               5)