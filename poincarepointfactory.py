# -*- coding: utf-8 -*-
"""PoincarePointFactory.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1flJKGfq0QpUhLj0pNq5lO1XSUZ0qocRU
"""

import numpy as np
from random import random
import math
import matplotlib.pyplot as plt
from random import random
from numpy import linalg as LA
from mpmath import *
mp.dps = 32

# poincare exponential
def lambda_x(x, c=1):
  """
  Compute the conformal factor ùúÜùëêùë• for a point on the ball
  that connects Euclidean inner product with Riemannian one
  """
  return 2/(1 - c*(np.dot(x, x)))

def riemannian_norm(v, x, c=1):
  return lambda_x(x, c)**c*sqrt(np.dot(v, v))

def mobius_add(x, y, c=1):
  """
  special operation over hyperbolic space
  """
  x_dot_y = np.dot(x, y)
  x_norm_q = np.dot(x, x)
  y_norm_q = np.dot(y, y)

  num = (1 + 2*c*x_dot_y + c*y_norm_q)*x + (1 - c*x_norm_q)*y
  den = 1 + 2*c*x_dot_y + c**2*x_norm_q*y_norm_q

  return num/den

def mobius_scalar_mul(r, x, c=1):
  x_norm_2 = sqrt(np.dot(x,x))
  sqrt_c = sqrt(c)
  return (1/sqrt_c)*tanh(r*atanh(sqrt_c*x_norm_2))*x/x_norm_2

def geodesic_unit(t, x, v, c=1):
  """
  Unit speed geodesic starting from x with direction v/‚Äñv‚Äñx
  """
  
  tmp = tanh(t*sqrt(c)/2)*(v/(sqrt(c)*sqrt(np.dot(v,v))))
  
  return mobius_add(x, tmp, c)

def poincare_exp(x, v, c=1):
  tmp = tanh(sqrt(c)/2*riemannian_norm(v, x, c))*(v/(sqrt(c)*sqrt(np.dot(v,v))))
  
  return mobius_add(x, tmp, c)

def poincare_dist(x, y):
  return acosh(1 + 2*(np.dot(x-y, x-y)/((1-np.dot(x,x))*(1-np.dot(y,y)))))

def grad_poincare_dist(x, y):
  a = 1 - np.dot(x, x)
  b = 1 - np.dot(y, y)
  c = 1 + 2/(a*b)*(np.dot(x-y, x-y))

  return 4/(b*sqrt(c**2-1))*(((np.dot(y,y) - 2*np.dot(x, y) + 1)/a**2)*x - y/a)

def frechet_mean_poincare_grad(psi, x_set):
  res = 0
  for x_i in x_set:
    res += poincare_dist(psi, x_i)*grad_poincare_dist(psi, x_i)
  return res*2*(len(x_set))

def frechet_mean_poincare_grad_euclidean(psi, x_set):
  return frechet_mean_poincare_grad(psi, x_set)*(lambda_x(psi)**2)

def poincare_transport(psi_1, psi_2, v):
  return v # identity transport, cercare un trasporto valido

def poincare_log(x, y, c=1):
  """
  Logarithmic map for two points ùë• and ùë¶ on the manifold.
  """
  a = mobius_add(-x, y, c)
  b = sqrt(np.dot(a, a))
  c = 2/(sqrt(c)*lambda_x(x, c))*atanh(sqrt(c)*b)
  return c*a/b

def optimisation_fl_poincare(psi_0, learning_rate, x_set, max_steps=10):
  x_set = np.array([[mpf(i) for i in x] for x in x_set])
  psi_seq = [psi_0]

  for i in range(max_steps):
    psi = psi_seq[-1]
    g = frechet_mean_poincare_grad(psi, x_set)
    new_psi=poincare_exp(psi, -learning_rate*g)
    
    psi_seq.append(new_psi)
  return psi_seq

x_set_s = [
           np.array([[-0.5, 0], [0.3, 0], [0.6, 0]], dtype=np.float64),
           np.array([[-0.5, 0.2, 0.1], [0.3, 0.2, 0.4], [0.6, 0.3, 0.2]], dtype=np.float64),
           np.array([[-0.5, 0.2, 0.1], [0.3, 0.2, 0.4], [-0.6, 0.3, 0.2], [0.2, 0, -0.4]], dtype=np.float64),
           np.array([[-0.5, 0.2, 0.1, 0.4], [0.3, 0.2, 0.4, 0.1], [0.6, 0.3, 0.2, 0.3]], dtype=np.float64)
          ]

def squeeze(x_set):
  points = []
  for x in x_set:
    points += x.tolist()
  return points

def format_data_to_save(x_set, limit):
  dim = x_set.shape[1]
  points = squeeze(x_set)
  return [dim] + points + limit.tolist()

def generate_starting_point(x_set):
    psi_0 = np.zeros(x_set.shape[1]) # poincare_points_factory() # calcolare come media dei punti x_set
    for a_i in x_set:
      psi_0 += a_i
    psi_0 /= len(x_set)
    return psi_0

def generate_to_save_data(x_set_s):
  to_save = []
  for x_set in x_set_s:
    psi_0 = generate_starting_point(x_set)
    
    psi_seq = optimisation_fl_poincare(psi_0, 0.005, x_set, 100)
    limit = psi_seq[-1]

    to_save.append(format_data_to_save(x_set, limit))

  return to_save

to_save = generate_to_save_data(x_set_s)

def save_to_file(to_save_data, file_name="points.txt"):
  with open(file_name, "w") as f:
    for data in to_save_data:
      f.write(",".join(str(i) for i in data) + "\n")

def generate_sets_from_file(file_name="points.txt"):
  x_set_s = []
  with open(file_name, "r") as f:
    for line in f.readlines():
      line_els = line.split(",")
      dim = int(line_els[0])
      limit = [mpf(i) for i in line_els[-dim:]]
      x_set = []
      for i in range(1, len(line_els)-dim, dim):
        x_set.append([float(i) for i in line_els[i:i+dim]])
      x_set = np.array(x_set)
      x_set_s.append((x_set, limit))
  return x_set_s

save_to_file(to_save)

generate_sets_from_file()